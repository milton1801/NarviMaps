<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>NarviMaps</title>

  <!-- MapLibre -->
  <link href="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.0/dist/maplibre-gl.js"></script>
  <link rel="stylesheet" href="first.css">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }
    #map { position: fixed; inset: 0; z-index: 0; }

    /* left panel */
    .panel {
      position: fixed;
      top: 100px;
      left: 50px;
      width: 400px;
      background: rgba(255,255,255,.95);
      border-radius: 14px;
      box-shadow: 0 10px 25px rgba(0,0,0,.2);
      padding: 16px;
      z-index: 7;
      min-height: 340px;
      transition: transform .18s ease, opacity .18s ease;
    }
    .panel.hidden { opacity: 0; transform: translateX(-12px); pointer-events: none; }

    .panel h3 {
      margin: 0 0 12px 2px;
      font-size: 24px;
      height: 30px;
      display: flex; align-items:center; gap:8px;
    }
    .row { position: relative; margin-bottom: 12px; }
    .panel input {
      width: 95%; height: 36px; padding: 8px 10px;
      border: 1px solid #ccc; border-radius: 8px; font-size: 15px;
    }
    .panel button {
      width: 100%; height: 46px; border: 0; border-radius: 8px;
      background: #4f46e5; color: #fff; cursor: pointer; font-size: 14px;
    }
    .panel button:hover { background: #3f3ad8; }

    /* autocomplete */
    .ac-list {
      position: absolute; top: calc(100% + 6px); left: 0; right: 0;
      background: #fff; border: 1px solid #e5e7eb; border-radius: 10px;
      margin: 0; padding: 6px 0; list-style: none; max-height: 220px; overflow: auto;
      box-shadow: 0 10px 24px rgba(0,0,0,.12); z-index: 12; display: none;
      font-family: inherit;
    }
    .ac-list.show { display:block; }
    .ac-list li { padding: 10px 12px; cursor:pointer; font-size:14px; font-family:inherit; }
    .ac-list li:hover { background:#f3f4f6; }

    .summary {
      margin-top: 10px; padding: 10px 12px; border: 1px solid #e5e7eb;
      border-radius: 10px; background: #f9fafb; font-size: 14px;
    }

    /* favorites - circular small icons */
    .fav-bar { display:flex; gap:8px; margin-top:8px; margin-bottom:8px; align-items:center; }
    .chip {
      width:44px;
      height:44px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      border-radius:50%;
      border:1px solid #e5e7eb;
      background:#fff;
      cursor:pointer;
      box-shadow: 0 4px 10px rgba(16,24,40,0.06);
      transition: transform .08s ease, background .12s ease;
      font-family: inherit;
    }
    .chip:hover { background:#eef2ff; transform: translateY(-2px); }
    .chip-small { width:36px; height:36px; font-size:16px; }

    /* recents */
    .latest-link { color:#4f46e5; cursor:pointer; font-size:14px; margin-bottom:6px; display:inline-block; }
    .latest-list { margin-top:6px; font-size:13px; max-height:160px; overflow:auto; font-family:inherit; }
    .latest-list div { padding:6px 4px; border-radius:6px; cursor:pointer; }
    .latest-list div:hover { background:#f3f4f6; }

    /* weather */
    .title-extra {
      font-weight:600; font-size:13px; padding:2px 8px;
      background:#eef2ff; color:#3730a3;
    }
    .weather {
      position: fixed; top: 10px; left: 55px; z-index: 8; font-size: 14px;
      color: #111827; background: rgba(255,255,255,.9); padding: 6px 10px;
      border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,.15);
    }
    .weather .chip { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; margin-left:6px; }

    /* top right buttons */
    #toggle-theme, #my-location-btn {
      position: fixed; top: 60px; z-index: 9; background:#4f46e5; color:#fff; border:none; border-radius:8px;
      padding:8px 12px; cursor:pointer; font-size:12px; display:flex; gap:8px;
    }
    #toggle-theme { right: 20px; } #my-location-btn { right: 140px; }
    #toggle-theme:hover, #my-location-btn:hover { background:#3f3ad8; }

    /* poi bar top-right - horizontally scrollable and same font */
    .poi-bar {
      position: fixed; top: 100px; right: 20px; z-index: 9;
      display:flex; gap:8px; flex-wrap:nowrap; max-width: 620px;
      overflow-x: auto; padding: 6px; align-items:center;
      background: transparent;
      scrollbar-width: thin;
      -webkit-overflow-scrolling: touch;
      font-family: inherit;
    }
    .poi-bar::-webkit-scrollbar { height: 8px; }
    .poi-bar::-webkit-scrollbar-thumb { background: rgba(15,23,42,0.15); border-radius: 999px; }
    .poi-bar::-webkit-scrollbar-track { background: transparent; }

    .poi-btn {
      flex: 0 0 auto; padding: 6px 12px; font-size: 13px; border-radius: 999px; border: none;
      background: #4f46e5; color: #fff; cursor:pointer; box-shadow: 0 4px 10px rgba(0,0,0,.12);
      display:inline-flex; gap:8px; align-items:center; white-space:nowrap; font-family: inherit;
    }
    .poi-btn:hover { background:#3f3ad8; transform: translateY(-2px); }

    /* place results container inside left panel */
    #poi-results {
      margin-top: 10px;
      font-family: inherit;
    }
    .poi-header { font-weight:700; margin-bottom:8px; font-size:14px; color:#111827; }
    .poi-meta { color:#6b7280; font-size:13px; margin-bottom:8px; }

    .poi-list {
      max-height: 220px;
      overflow-y: auto;
      padding-right: 6px;
    }
    .poi-item {
      padding:8px 6px;
      border-radius:6px;
      cursor:pointer;
      font-size:14px;
      color:#111827;
      display:block;
    }
    .poi-item:hover { background:#f3f4f6; }
    .poi-name { font-weight:600; font-size:14px; margin-bottom:4px; }
    .poi-meta-small { color:#6b7280; font-size:13px; }

    .poi-rating {
      display:flex;
      align-items:center;
      gap:8px;
      font-size:13px;
      color:#111827;
    }
    .poi-stars {
      color: #f59e0b;
      font-size:14px;
      letter-spacing: 0.6px;
      display:inline-flex;
      align-items:center;
    }
    .poi-rating small {
      color:#6b7280;
      font-weight:600;
      margin-left:4px;
      font-size:12px;
    }

    /* mode chooser box */
    .mode-box {
      position: fixed;
      top: 120px;
      left: 100px;
      width: 440px;
      background: rgba(255,255,255,0.98);
      border-radius: 12px;
      box-shadow: 0 14px 30px rgba(0,0,0,.22);
      padding: 12px;
      z-index: 11;
      display: none;
      transition: opacity .12s ease, transform .12s ease;
      font-family: inherit;
    }
    .mode-box.show { display:block; opacity:1; transform: none; }
    .mode-header { display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px; }
    .mode-left { display:flex; gap:8px; align-items:center; }
    .mode-back {
      background: transparent; color: #4f46e5; border:none; font-size:14px; cursor:pointer; padding:6px;
    }
    .mode-title { font-weight:600; font-size:16px; }
    .mode-grid { display:flex; gap:8px; }
    .mode-btn {
      flex:1;height:50px; padding:10px 12px; border-radius:10px; border:none; background:#4f46e5; color:#fff; cursor:pointer; font-size:15px;
      box-shadow: 0 6px 12px rgba(0,0,0,.08);
    }
    .mode-btn:hover { background:#3f3ad8; transform: translateY(-2px); }
    .mode-btn.active { background:#111827; }

    /* Go button row (inside silver box) */
    .mode-go-row {
      margin-top: -60px;
      display:flex;
      justify-content:flex-end;
    }
    .mode-go-btn {
      padding:8px 16px;
      border-radius:10px;
      border:none;
      background:#22c55e;
      color:#fff;
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      box-shadow:0 6px 12px rgba(0,0,0,.12);
      display:inline-flex;
      align-items:center;
      gap:6px;
      height: 50px;
    }
    .mode-go-btn[disabled] {
      opacity:0.55;
      cursor:default;
      box-shadow:none;
    }
    .mode-go-btn:hover:not([disabled]) {
      background:#16a34a;
      transform:translateY(-1px);
    }

    .mode-result {
      margin-top:10px;
      padding:10px;
      background:#f8fafc;
      border-radius:8px;
      font-size:15px;
      display:none;
      flex-direction:column;
      gap:8px;
    }

    /* directions list */
    .mode-directions {
      margin-top:8px;
      max-height:220px;
      overflow-y:auto;
      font-size:14px;
      padding-left:4px;
    }
    .mode-directions ol {
      padding-left:20px;
      margin:0;
    }
    .mode-directions li {
      margin-bottom:4px;
    }
    .mode-directions small {
      color:#6b7280;
      margin-left:4px;
    }

    /* NEW: wrapper + title for directions box */
    .directions-wrapper {
      margin-top: 10px;
      padding: 10px 12px;
      background: #f3f4f6;
      border-radius: 8px;
      display: none;
      font-size: 14px;
    }
    .directions-title {
      font-weight: 600;
      margin-bottom: 6px;
      color: #111827;
    }

    /* PHONE LAYOUT ‚Äì Apple Maps style */
/* PHONE LAYOUT ‚Äì only destination search */
@media (max-width: 600px) {

html, body {
  height: 100%;
  margin: 0;
  overflow-y: auto;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
}

/* Full-screen map behind */
#map {
  position: fixed;
  inset: 0;
  z-index: 0;
}

/* Compact panel near top, like a single search bar */
.panel {
  position: fixed;
  top: 120px;
  left: 50%;
  transform: translateX(-50%);
  width: calc(100% - 32px);
  min-height: auto;
  background: rgba(255,255,255,0.97);
  border-radius: 16px;
  box-shadow: 0 10px 24px rgba(0,0,0,0.28);
  padding: 10px 12px 14px;
  z-index: 7;
}

.panel h3 {
  font-size: 18px;
  margin-bottom: 6px;
}

.title-extra {
  font-size: 12px;
  padding: 2px 8px;
}

.row {
  margin-bottom: 8px;
}

/* hide the FROM row on phone */
.row-from {
  display: none;
}

.panel input {
  width: 100%;
  height: 36px;
  font-size: 14px;
  padding: 6px 9px;
}

.panel button {
  height: 40px;
  font-size: 15px;
  margin-top: 4px;
}

/* hide all the extra stuff on mobile */
.summary,
.fav-bar,
#latest-trips-toggle,
#latest-trips,
#poi-results,
.poi-bar {
  display: none !important;
}

/* weather centered at very top */
.weather {
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 13px;
  padding: 4px 8px;
  border-radius: 999px;
}

/* top buttons smaller */
#my-location-btn,
#toggle-theme {
  top: 60px;
  font-size: 11px;
  padding: 6px 8px;
}

#my-location-btn {
  left: 10px;
  right: auto;
}

#toggle-theme {
  right: 10px;
  left: auto;
}

/* mode box behaves like a full-screen dialog */
.mode-box {
  top: 80px;
  left: 0;
  right: 0;
  bottom: 0;
  width: 100%;
  max-height: calc(100vh - 80px);
  border-radius: 18px 18px 0 0;
  box-shadow: 0 -8px 24px rgba(0,0,0,0.35);
  overflow-y: auto;
}

.mode-btn {
  height: 44px;
  font-size: 14px;
}

.mode-go-btn {
  height: 44px;
  font-size: 13px;
}

.mode-directions {
  max-height: 220px;
  font-size: 13px;
}
}







  </style>
</head>
<body>
  <div id="map"></div>

  <!-- LEFT PANEL -->
  <div class="panel" id="left-panel">
    <h3> NarviMaps <span id="user-location" class="title-extra"></span> </h3>

    <div class="row row-from">
      <input id="from" placeholder="From..." autocomplete="off" />
      <ul class="ac-list" id="from-list"></ul>
    </div>
    

    <div class="row">
      <input id="to" placeholder="To..." autocomplete="off" />
      <ul class="ac-list" id="to-list"></ul>
    </div>

    <button id="go">Search route</button>

    <div id="summary" class="summary"></div>

    <!-- Favorites -->
    <div id="favorites" class="fav-bar" role="group" aria-label="Favorites">
      <button id="fav-home" class="chip" title="Home">üè†</button>
      <button id="fav-work" class="chip" title="Work">üíº</button>
      <button id="fav-save" class="chip chip-small" title="Save">Ôºã</button>
    </div>

    <div class="row">
      <div id="latest-trips-toggle" class="latest-link">Latest trips ‚ñæ</div>
      <div id="latest-trips" class="latest-list"></div>
    </div>

    <div id="poi-results"></div>
  </div>

  <!-- WEATHER -->
  <div id="weather" class="weather">Loading weather‚Ä¶</div>

  <!-- toggles -->
  <button id="my-location-btn">üìç My Location</button>
  <button id="toggle-theme">üåô Night Mode</button>

  <!-- POI buttons -->
  <div class="poi-bar" id="poi-bar">
    <button class="poi-btn" data-type="restaurants">üçΩ Restaurants</button>
    <button class="poi-btn" data-type="fastfood">üçü Fast food</button>
    <button class="poi-btn" data-type="gas">‚õΩ Gas</button>
    <button class="poi-btn" data-type="grocery">üõí Groceries</button>
    <button class="poi-btn" data-type="hotel">üè® Hotels</button>
    <button class="poi-btn" data-type="hospital">üè• Hospitals</button>
  </div>

  <!-- MODE BOX -->
  <div id="mode-box" class="mode-box" aria-hidden="true">
    <div class="mode-header">
      <div class="mode-left">
        <button id="mode-back" class="mode-back">‚Üê Back</button>
        <div class="mode-title">Choose transport</div>
      </div>
      <div id="mode-summary-mini" style="font-size:13px;color:#6b7280"></div>
    </div>

    <div class="mode-grid">
      <button class="mode-btn" data-mode="drive">üöó Car</button>
      <button class="mode-btn" data-mode="walk">üö∂ Walk</button>
      <button class="mode-btn" data-mode="bicycle">üö≤ Bike</button>
      <button class="mode-btn" data-mode="transit">üöÜ Transit</button>
    </div>

    <!-- Silver box that contains distance + Go -->
    <div id="mode-result" class="mode-result">
      <div id="mode-result-text"></div>
      <div class="mode-go-row">
        <button id="mode-go" class="mode-go-btn" disabled>Go ‚Üí</button>
      </div>
    </div>

    <!-- New directions wrapper box -->
    <div id="directions-wrapper" class="directions-wrapper">
      <div class="directions-title">Step-by-step directions</div>
      <div id="directions" class="mode-directions"></div>
    </div>
  </div> <!-- ‚úÖ close mode-box -->

  <script>
    const DEBUG_SCREENSHOT_URL = "sandbox:/mnt/data/Screenshot 2025-11-18 at 7.24.14 PM.png";

    const KEY  = "67e005d9fe194322bef4dc183e06d24b";
    const BIAS = [-93.2650, 44.9778]; // [lon, lat]
    const state = { from: null, to: null };

    let currentMode = "drive";
    let modeBoxReady = false;

    const map = new maplibregl.Map({
      container: 'map',
      style: `https://maps.geoapify.com/v1/styles/osm-carto/style.json?apiKey=${KEY}`,
      center: BIAS,
      zoom: 12
    });
    map.addControl(new maplibregl.NavigationControl(), 'bottom-right');

    const debounce = (fn, ms=250) => {
      let t;
      return (...a) => { clearTimeout(t); t = setTimeout(()=>fn(...a), ms); };
    };

    const acURL = (q) =>
      `https://api.geoapify.com/v1/geocode/autocomplete?text=${encodeURIComponent(q)}&limit=5&filter=countrycode:us&bias=proximity:${BIAS[0]},${BIAS[1]}&apiKey=${KEY}`;

    async function suggest(query, which){
      const ul = document.getElementById(`${which}-list`);
      if (!query.trim()) { ul.innerHTML=""; ul.classList.remove("show"); return; }
      try {
        const res = await fetch(acURL(query));
        const data = await res.json();
        const items = (data.features || []).map(f => ({
          label: f.properties.formatted || f.properties.address_line1 || f.properties.name,
          lat: f.properties.lat,
          lon: f.properties.lon
        }));
        renderList(which, items);
      } catch(e) {
        console.warn("Autocomplete error", e);
        ul.innerHTML=""; ul.classList.remove("show");
      }
    }

    function renderList(which, items){
      const ul = document.getElementById(`${which}-list`);
      ul.innerHTML = "";
      if (!items.length) { ul.classList.remove("show"); return; }
      for (const item of items) {
        const li = document.createElement("li");
        li.textContent = item.label;
        li.onclick = () => {
          document.getElementById(which).value = item.label;
          state[which] = { lat: item.lat, lon: item.lon, label: item.label };
          ul.classList.remove("show");
        };
        ul.appendChild(li);
      }
      ul.classList.add("show");
    }

    document.addEventListener("click", (e) => {
      if (!e.target.closest(".row")) {
        document.querySelectorAll(".ac-list").forEach(ul => ul.classList.remove("show"));
      }
    });

    document.getElementById("from").addEventListener("input", debounce(e => suggest(e.target.value, "from"), 200));
    document.getElementById("to").addEventListener("input", debounce(e => suggest(e.target.value, "to"), 200));

    async function geocodeLabel(label) {
      if (!label) return null;
      const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(label)}&limit=1&apiKey=${KEY}`;
      try {
        const r = await fetch(url);
        if (!r.ok) return null;
        const j = await r.json();
               const f = j.features?.[0];
        if (!f) return null;
        const [lon, lat] = f.geometry.coordinates;
        return { lat, lon, label: f.properties.formatted || label };
      } catch(e) {
        console.warn("geocodeLabel error", e);
        return null;
      }
    }

    function formatTime(seconds) {
      if (!seconds || seconds <= 0) return "0 min";
      const mins = Math.round(seconds/60);
      if (mins < 60) return `${mins} min`;
      const hrs = Math.floor(mins/60);
      const rem = mins % 60;
      return rem === 0 ? `${hrs} hr` : `${hrs} hr ${rem} min`;
    }

    const YELP_CACHE_KEY = "narvimaps_yelp_cache_v1";
    function loadYelpCache() {
      try { return JSON.parse(localStorage.getItem(YELP_CACHE_KEY) || "{}"); } catch(e) { return {}; }
    }
    function saveYelpCache(cache) {
      try { localStorage.setItem(YELP_CACHE_KEY, JSON.stringify(cache)); } catch(e) {}
    }

    function renderStarsHTML(rating) {
      if (typeof rating !== "number") return "";
      const full = Math.floor(rating);
      const half = (rating - full) >= 0.5 ? 1 : 0;
      const empty = 5 - full - half;
      let out = "";
      for (let i=0;i<full;i++) out += "‚òÖ";
      if (half) out += "‚òÖ";
      for (let i=0;i<empty;i++) out += "‚òÜ";
      return `<span class="poi-stars">${out}</span>`;
    }

    async function safeReadText(resp) {
      try { return await resp.text(); } catch (e) { return "(unable to read response body)"; }
    }

    async function fetchYelpRatingFor(name, lat, lon) {
      const cache = loadYelpCache();
      const key = `${name}|${lat.toFixed(4)},${lon.toFixed(4)}`;
      const now = Date.now();
      if (cache[key] && (now - cache[key].ts) < (1000 * 60 * 60 * 24)) {
        return cache[key].data;
      }

      const params = new URLSearchParams({ name, latitude: String(lat), longitude: String(lon) });
      const candidatePaths = [`/api/yelp/search?${params.toString()}`, `/api/yelp-search?${params.toString()}`];

      let lastErr = null;
      for (const p of candidatePaths) {
        try {
          const r = await fetch(p);
          if (!r.ok) {
            const txt = await safeReadText(r);
            console.warn(`Yelp proxy returned ${r.status} for ${p}:`, txt);
            lastErr = { status: r.status, body: txt, path: p };
            if (r.status === 404) continue;
            continue;
          }
          const j = await r.json();
          const out = j.found ? { rating: j.rating, review_count: j.review_count, url: j.url } : null;
          cache[key] = { ts: Date.now(), data: out };
          saveYelpCache(cache);
          return out;
        } catch (e) {
          console.warn(`Fetch to ${p} failed:`, e);
          lastErr = e;
        }
      }

      console.warn("All Yelp proxy attempts failed:", lastErr);
      return null;
    }

    async function fetchRatingsForList(items, onItemResult) {
      for (let i=0;i<items.length;i++) {
        const it = items[i];
        try {
          const y = await fetchYelpRatingFor(it.name, it.lat, it.lon);
          onItemResult(i, y);
        } catch(e) {
          onItemResult(i, null);
        }
        await new Promise(r => setTimeout(r, 140));
      }
    }

    let segIds = [];
    let startMarker = null;
    let destMarker  = null;

    async function drawRoute(modeArg = "drive", showDirections = true) {

      if (!state.from || !state.to ||
         typeof state.from.lat !== "number" || typeof state.from.lon !== "number" ||
         typeof state.to.lat !== "number" || typeof state.to.lon !== "number") {
        alert("Pick both From and To (or let the app geocode typed addresses).");
        return;
      }

      const wp = p => `${p.lat},${p.lon}`;
      const PURPLE = "#4f46e5", YELLOW = "#f59e0b", RED = "#e11d48";

      const acceptedModes = new Set(["drive","walk","bicycle","transit"]);
      const mode = acceptedModes.has(modeArg) ? modeArg : "drive";

      const buildURLWithTraffic = (trafficMode) =>
        `https://api.geoapify.com/v1/routing?waypoints=${wp(state.from)}|${wp(state.to)}` +
        `&mode=${mode}` + (trafficMode ? `&traffic=${trafficMode}` : ``) + `&apiKey=${KEY}`;

      const buildURLNoTraffic = () =>
        `https://api.geoapify.com/v1/routing?waypoints=${wp(state.from)}|${wp(state.to)}` +
        `&mode=${mode}&apiKey=${KEY}`;

      let res, json;
      try {
        if (mode === "drive") {
          let url = buildURLWithTraffic("approximated");
          res = await fetch(url);
          if (!res.ok) {
            const bodyText = await safeReadText(res);
            console.error("Routing call failed (approximated):", res.status, bodyText, url);

            url = buildURLWithTraffic("free_flow");
            res = await fetch(url);
            if (!res.ok) {
              const bodyText2 = await safeReadText(res);
              console.error("Routing call failed (free_flow):", res.status, bodyText2, url);

              url = buildURLNoTraffic();
              res = await fetch(url);
              if (!res.ok) {
                const bodyText3 = await safeReadText(res);
                console.error("Routing call failed (no traffic):", res.status, bodyText3, url);
                throw new Error(`Routing failed (${res.status}): ${bodyText3 || "(no body)"} (url: ${url})`);
              }
            }
          }
        } else {
          const url = buildURLNoTraffic();
          res = await fetch(url);
          if (!res.ok) {
            const bodyText = await safeReadText(res);
            console.error("Routing call failed:", res.status, bodyText, url);
            throw new Error(`Routing failed (${res.status}): ${bodyText || "(no body)"} (url: ${url})`);
          }
        }
        json = await res.json();
      } catch (err) {
        console.error("Routing error:", err);
        alert("Routing failed. See console for details.\n\n" + (err.message || ""));
        return;
      }

      if (!json.features || !json.features.length) {
        alert("No route found.");
        return;
      }

      const feature = json.features[0];
      const props   = feature.properties || {};

      for (const id of segIds) {
        if (map.getLayer(id.layer)) map.removeLayer(id.layer);
        if (map.getSource(id.source)) map.removeSource(id.source);
      }
      segIds = [];
      ["route-line","route-casing"].forEach(id => { if (map.getLayer(id)) map.removeLayer(id); });
      if (map.getSource("narvi-route")) map.removeSource("narvi-route");

      let lineCoords = [];
      if (feature.geometry.type === "LineString") lineCoords = feature.geometry.coordinates;
      else if (feature.geometry.type === "MultiLineString") lineCoords = feature.geometry.coordinates.flat();

      const leg = props.legs?.[0] || null;
      const steps = Array.isArray(leg?.steps) ? leg.steps : [];
      let drewSegments = false;

      if (mode === "drive" && steps.length &&
         typeof steps[0]?.from_index === "number" && typeof steps[0]?.to_index === "number" &&
         lineCoords.length) {

        const colorForStep = (step) => {
          const cur  = step.speed_with_traffic ?? step.current_speed ?? step.speed ?? null;
          const free = step.free_flow_speed   ?? step.speed         ?? null;
          if (cur && free) {
            const ratio = cur / free;
            if (ratio < 0.60) return RED;
            if (ratio < 0.85) return YELLOW;
            return PURPLE;
          }
          const delay = step.delay ?? 0;
          const distM = step.distance ?? 0;
          const dpk   = distM > 0 ? delay / (distM / 1000) : 0;
          if (dpk > 60) return RED;
          if (dpk > 20) return YELLOW;
          return PURPLE;
        };

        steps.forEach((step, i) => {
          const a = Math.max(0, Math.min(step.from_index, lineCoords.length - 1));
          const b = Math.max(0, Math.min(step.to_index,   lineCoords.length - 1));
          if (b <= a) return;
          const segCoords = lineCoords.slice(a, b + 1);
          const segColor  = colorForStep(step);
          const srcId = `narvi-seg-src-${i}`;
          const layerId = `narvi-seg-${i}`;
          map.addSource(srcId, { type: "geojson", data: { type:"Feature", geometry:{ type:"LineString", coordinates: segCoords } } });
          map.addLayer({ id: layerId, type: "line", source: srcId, paint: { "line-width": 6, "line-color": segColor, "line-opacity": 0.95 } });
          segIds.push({ source: srcId, layer: layerId });
          drewSegments = true;
        });

        if (drewSegments) {
          let b = new maplibregl.LngLatBounds(lineCoords[0], lineCoords[0]);
          for (const c of lineCoords) b.extend(c);
          map.fitBounds(b, { padding: 60, duration: 600 });
        }
      }

      if (!drewSegments) {
        map.addSource("narvi-route", { type: "geojson", data: feature });
        map.addLayer({ id:"route-casing", type:"line", source:"narvi-route", paint:{ "line-width":10, "line-color":"#fff", "line-opacity":0.6 } });
        map.addLayer({ id:"route-line", type:"line", source:"narvi-route", paint:{ "line-width":6, "line-color":"#4f46e5", "line-opacity":0.95 } });
        const coords = feature.geometry.type === "LineString" ? feature.geometry.coordinates : feature.geometry.coordinates.flat();
        if (coords.length) {
          let b = new maplibregl.LngLatBounds(coords[0], coords[0]);
          for (const c of coords) b.extend(c);
          map.fitBounds(b, { padding: 60, duration: 600 });
        }
      }

      const meters  = props.distance ?? 0;
      const seconds = props.time ?? 0;
      const miles = meters / 1609.344;
      const km    = meters / 1000;

      let desc;
      if (mode === "drive") {
        desc = drewSegments ? "Drive (traffic)" : "Drive";
      } else if (mode === "walk") {
        desc = "Walk";
      } else if (mode === "bicycle") {
        desc = "Bicycle";
      } else if (mode === "transit") {
        desc = "Transit";
      } else {
        desc = "Route";
      }

      const modeResult = document.getElementById("mode-result");
      const modeResultText = document.getElementById("mode-result-text");
      if (modeResult) modeResult.style.display = "flex";
      if (modeResultText) {
        modeResultText.innerHTML = `
          <strong>${desc}</strong><br>
          Distance: ${miles.toFixed(1)} mi (${km.toFixed(1)} km)<br>
          Estimated time: ${formatTime(seconds)}
        `;
      }

      const mini = document.getElementById("mode-summary-mini");
      if (mini) mini.textContent = `${miles.toFixed(1)} mi ‚Ä¢ ${formatTime(seconds)}`;

      const startLL = [state.from.lon, state.from.lat];
      const endLL   = [state.to.lon, state.to.lat];

      if (startMarker) startMarker.remove();
      if (destMarker)  destMarker.remove();

      const startEl = document.createElement("div");
      startEl.style.width = "10px"; startEl.style.height = "10px";
      startEl.style.borderRadius = "9999px"; startEl.style.background = "#4f46e5";
      startEl.style.border = "2px solid #fff"; startEl.style.boxShadow = "0 1px 2px rgba(0,0,0,.35)";
      startMarker = new maplibregl.Marker({ element: startEl, anchor: "center" }).setLngLat(startLL).addTo(map);

      const flagEl = document.createElement("div");
      flagEl.style.fontSize = "20px"; flagEl.textContent = "üèÅ";
      destMarker = new maplibregl.Marker({ element: flagEl, anchor: "bottom" }).setLngLat(endLL).addTo(map);

      const dirBox = document.getElementById("directions");
      const dirWrapper = document.getElementById("directions-wrapper");

      if (!showDirections) {
        // Hide directions when just previewing mode
        if (dirBox) dirBox.innerHTML = "";
        if (dirWrapper) dirWrapper.style.display = "none";
      } else if (dirBox) {
        if (!steps.length) {
          dirBox.innerHTML = "";
          if (dirWrapper) dirWrapper.style.display = "none";
        } else {
          const html = steps.map((s, i) => {
            const instr = (s.instruction && (s.instruction.text || s.instruction)) ||
                          s.text || s.name || s.street || "Step";
            const distM = s.distance ?? 0;
            const dist = distM ? `${(distM/1609.344).toFixed(2)} mi` : "";
            return `<li>${i+1}. ${instr}${dist ? `<small>${dist}</small>` : ""}</li>`;
          }).join("");

          dirBox.innerHTML = `<ol>${html}</ol>`;

          if (dirWrapper) {
            dirWrapper.style.display = "block";
            dirWrapper.scrollTop = 0;
          }
        }
      }
    } // ‚úÖ close drawRoute properly

    function saveRecentSearch(fromLabel, toLabel) {
      if (!fromLabel || !toLabel) return;
      const MAX = 5; const key = "narvimaps_recents";
      let list = JSON.parse(localStorage.getItem(key) || "[]");
      list = list.filter(item => !(item.from === fromLabel && item.to === toLabel));
      list.unshift({ from: fromLabel, to: toLabel, time: Date.now() });
      if (list.length > MAX) list = list.slice(0, MAX);
      localStorage.setItem(key, JSON.stringify(list));
      renderRecents();
    }

    function renderRecents() {
      const key = "narvimaps_recents";
      const list = JSON.parse(localStorage.getItem(key) || "[]");
      const box = document.getElementById("latest-trips");
      const toggle = document.getElementById("latest-trips-toggle");
      if (!box || !toggle) return;
      box.innerHTML = "";
      if (!list.length) { box.style.display = "none"; toggle.style.display = "none"; return; }
      toggle.style.display = "inline-block";
      list.forEach(item => {
        const div = document.createElement("div");
        div.className = "latest-item"; div.textContent = `${item.from} ‚Üí ${item.to}`;
        div.onclick = () => {
          const fromInput = document.getElementById("from"); const toInput = document.getElementById("to");
          if (fromInput) fromInput.value = item.from; if (toInput) toInput.value = item.to;
          state.from = null; state.to = null;
        };
        box.appendChild(div);
      });
    }
    (function initLatestTripsToggle(){
      const toggle = document.getElementById("latest-trips-toggle");
      const box = document.getElementById("latest-trips");
      if (!toggle || !box) return;
      let open = true;
      const update = () => { box.style.display = open ? "block" : "none"; toggle.textContent = open ? "Latest trips ‚ñæ" : "Latest trips ‚ñ∏"; };
      toggle.addEventListener("click", ()=>{ open = !open; update(); });
      update();
    })();

    const PLACES_KEY = "narvi_places";
    const ICON = (name) => name === "Home" ? "üè†" : name === "Work" ? "üíº" : "üìç";
    function getPlaces(){ try { return JSON.parse(localStorage.getItem(PLACES_KEY) || "[]"); } catch { return []; } }
    function setPlaces(list){ localStorage.setItem(PLACES_KEY, JSON.stringify(list)); }

    async function geocode(text) {
      const url = `https://api.geoapify.com/v1/geocode/search?text=${encodeURIComponent(text)}&limit=1&apiKey=${KEY}`;
      const r = await fetch(url); if (!r.ok) return null;
      const j = await r.json();
      const f = j.features?.[0]; if (!f) return null;
      const [lon, lat] = f.geometry.coordinates;
      return { lon, lat, label: f.properties.formatted || text };
    }

    let favMarkers = [];
    function renderFavMarkers(){
      favMarkers.forEach(m => m.remove()); favMarkers = [];
      const places = getPlaces();
      places.forEach(p => {
        if (typeof p.lon !== "number" || typeof p.lat !== "number") return;
        const el = document.createElement("div"); el.style.fontSize = "22px"; el.textContent = ICON(p.name);
        const marker = new maplibregl.Marker({ element: el, anchor: "bottom" })
          .setLngLat([p.lon,p.lat])
          .setPopup(new maplibregl.Popup({ offset: 12 }).setText(p.name))
          .addTo(map);
        marker.getElement().addEventListener("click", () => routeToSaved(p.name));
        favMarkers.push(marker);
      });
    }

    function upsertPlace(name, lon, lat) {
      const list = getPlaces();
      const idx = list.findIndex(p => p.name.toLowerCase() === name.toLowerCase());
      const rec = { name, lon, lat }; if (idx >= 0) list[idx] = rec; else list.push(rec);
      setPlaces(list);
      renderFavMarkers();
    }

    function routeToSaved(name) {
      const p = getPlaces().find(x => x.name.toLowerCase() === name.toLowerCase());
      if (!p) { alert(`${name} is not set yet.`); return; }
      state.to = { lon: p.lon, lat: p.lat, label: name };
      const to = document.getElementById("to"); if (to) to.value = name;
      if (!state.from || typeof state.from.lat !== "number" || typeof state.from.lon !== "number") {
        const c = map.getCenter();
        state.from = { lat: c.lat, lon: c.lng, label: "Map center" };
        const from = document.getElementById("from"); if (from && !from.value) from.value = "Map center";
      }
      showModeChoice();
    }

    async function ensureSlot(slotName) {
      const existing = getPlaces().find(p => p.name.toLowerCase() === slotName.toLowerCase());
      if (existing) { routeToSaved(slotName); return; }
      const addr = prompt(`${slotName} not set. Enter an address:`, "");
      if (!addr) return;
      const g = await geocode(addr);
      if (!g) { alert("Address not found."); return; }
      upsertPlace(slotName, g.lon, g.lat);
      routeToSaved(slotName);
    }

    document.getElementById("fav-home").addEventListener("click", ()=>ensureSlot("Home"));
    document.getElementById("fav-work").addEventListener("click", ()=>ensureSlot("Work"));
    document.getElementById("fav-save").addEventListener("click", async () => {
      const toVal = document.getElementById("to").value.trim();
      let label = prompt("Save as (e.g., 'Gym', 'School'):", toVal || "Favorite");
      if (!label) return;
      let lon = state.to?.lon, lat = state.to?.lat;
      if (typeof lon !== "number" || typeof lat !== "number") {
        const addr = toVal || prompt("Enter address to save:", ""); if (!addr) return;
        const g = await geocode(addr); if (!g) { alert("Address not found."); return; }
        lon = g.lon; lat = g.lat;
      }
      upsertPlace(label, lon, lat);
      routeToSaved(label);
    });

    const POI_RADIUS_M = 8047;
    let poiMarkers = [];
    function clearPoiMarkers(){ poiMarkers.forEach(m => m.remove()); poiMarkers = []; }

    function milesBetween(lat1, lon1, lat2, lon2) {
      const R = 3958.7613;
      const toRad = d => d * Math.PI/180;
      const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function choosePoiOrigin() {
      if (state.from && typeof state.from.lat === "number" && typeof state.from.lon === "number") {
        return { lat: state.from.lat, lon: state.from.lon, label: state.from.label || "Start" };
      }
      const c = map.getCenter();
      return { lat: c.lat, lon: c.lng, label: "map center" };
    }

    async function loadPOIs(categories, label) {
      const origin = choosePoiOrigin();
      const url = `https://api.geoapify.com/v2/places?categories=${encodeURIComponent(categories)}&filter=circle:${origin.lon},${origin.lat},${POI_RADIUS_M}&bias=proximity:${origin.lon},${origin.lat}&limit=30&lang=en&apiKey=${KEY}`;
      let data;
      try {
        const r = await fetch(url); if (!r.ok) { alert(`Couldn't load ${label} nearby.`); return; }
        data = await r.json();
      } catch(e) { alert(`Couldn't load ${label} nearby.`); return; }
      const feats = Array.isArray(data.features) ? data.features : [];
      const items = feats.map(f => {
        const [lon, lat] = f.geometry.coordinates; const p = f.properties || {};
        const name = p.name || p.address_line1 || "Place"; const addr = p.formatted || "";
        const mi = milesBetween(origin.lat, origin.lon, lat, lon);
        return { name, addr, lat, lon, mi };
      }).filter(it => it.mi <= 10).sort((a,b)=>a.mi-b.mi).slice(0,12);
      renderPOIResults(items, label, origin);
    }

    function renderPOIResults(items, label, origin) {
      const box = document.getElementById("poi-results"); clearPoiMarkers(); box.innerHTML = "";
      if (!items.length) {
        box.innerHTML = `<div class="poi-header">${label} near ${origin.label}</div><div class="poi-meta">No results within about 5‚Äì10 miles.</div>`;
        return;
      }
      const bounds = new maplibregl.LngLatBounds([origin.lon, origin.lat],[origin.lon, origin.lat]);
      items.forEach((it, idx) => {
        const marker = new maplibregl.Marker({ color: idx===0?"#4f46e5":"#111827" })
          .setLngLat([it.lon, it.lat])
          .setPopup(new maplibregl.Popup({ offset: 10 }).setHTML(`<strong>${it.name}</strong><br>${it.addr || ""}<br>${it.mi.toFixed(1)} mi`))
          .addTo(map);
        poiMarkers.push(marker); bounds.extend([it.lon, it.lat]);
      });
      map.fitBounds(bounds, { padding: 60, duration: 600 });

      box.innerHTML = `<div class="poi-header">${label} near ${origin.label}</div>
        <div class="poi-meta">Showing ${items.length} results</div>
        <div class="poi-list">` + items.map((it, idx) => `
        <div class="poi-item" data-lat="${it.lat}" data-lon="${it.lon}" data-label="${it.name.replace(/"/g,"&quot;")}" data-idx="${idx}">
          <div style="display:flex; align-items:center; justify-content:space-between;">
            <div class="poi-name">${idx+1}. ${it.name}</div>
            <div class="poi-rating" id="poi-rating-${idx}"><small style="color:#6b7280">Loading‚Ä¶</small></div>
          </div>
          <div class="poi-meta-small">${it.mi.toFixed(1)} mi ‚Ä¢ ${it.addr || ""}</div>
        </div>
      `).join("") + `</div>`;

      box.querySelectorAll(".poi-item").forEach(el => {
        el.addEventListener("click", () => {
          const lat = parseFloat(el.dataset.lat), lon = parseFloat(el.dataset.lon), label = el.dataset.label || "Destination";
          const toInput = document.getElementById("to"); if (toInput) toInput.value = label;
          state.to = { lat, lon, label };
          if (!state.from || typeof state.from.lat !== "number" || typeof state.from.lon !== "number") {
            const origin2 = choosePoiOrigin();
            state.from = { lat: origin2.lat, lon: origin2.lon, label: origin2.label };
            const fromInput = document.getElementById("from"); if (fromInput && !fromInput.value) fromInput.value = origin2.label;
          }
          const fromLabel = document.getElementById("from")?.value.trim() || state.from.label;
          const toLabel   = document.getElementById("to")?.value.trim()   || state.to.label;
          if (fromLabel && toLabel) saveRecentSearch(fromLabel, toLabel);
          showModeChoice();
        });
      });

      fetchRatingsForList(items, (idx, yelpData) => {
        const slot = document.getElementById(`poi-rating-${idx}`);
        if (!slot) return;
        if (yelpData && typeof yelpData.rating === "number") {
          slot.innerHTML = `${renderStarsHTML(yelpData.rating)} <small>(${yelpData.review_count || 0})</small>`;
          if (yelpData.url) {
            slot.style.cursor = "pointer";
            slot.addEventListener("click", (e) => {
              e.stopPropagation();
              window.open(yelpData.url, "_blank");
            }, { once: true });
          }
        } else {
          slot.innerHTML = `<small style="color:#6b7280">‚Äî</small>`;
        }
      });
    }

    const POI_TYPE_MAP = {
      restaurants: "catering.restaurant,catering.fast_food",
      fastfood: "catering.fast_food",
      gas: "service.vehicle.fuel",
      grocery: "commercial.supermarket,commercial.convenience",
      hotel: "accommodation.hotel,accommodation.motel,accommodation.hostel,accommodation.guest_house",
      hospital: "healthcare.hospital,healthcare.clinic",
      parking: "amenity.parking",
      atm: "amenity.atm",
      bank: "amenity.bank",
      pharmacy: "amenity.pharmacy",
      park: "leisure.park",
      cafe: "catering.cafe"
    };

    document.querySelectorAll(".poi-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        const type = btn.dataset.type;
        const categories = POI_TYPE_MAP[type] || type;
        loadPOIs(categories, btn.textContent || type);
      });
    });

    function getMyLocation(){
      if (!navigator.geolocation) { alert("Geolocation is not supported by your browser"); return; }
      navigator.geolocation.getCurrentPosition((pos)=>{
        const lat = pos.coords.latitude, lon = pos.coords.longitude;
        new maplibregl.Marker({ color: "#4f46e5" }).setLngLat([lon,lat]).addTo(map);
        map.flyTo({ center: [lon, lat], zoom: 13 });
        state.from = { lat, lon, label: "My location" };
        const fromInput = document.getElementById("from"); if (fromInput) fromInput.value = "My location";
        updateWeatherAndTitle(lat, lon);
      }, (err)=>{ console.warn(err); alert("Unable to get your location. Please allow location access."); });
    }
    document.getElementById("my-location-btn").addEventListener("click", getMyLocation);

    let darkMode = false;
    document.getElementById("toggle-theme").addEventListener("click", () => {
      darkMode = !darkMode;
      const styleUrl = darkMode ? `https://maps.geoapify.com/v1/styles/dark-matter/style.json?apiKey=${KEY}` : `https://maps.geoapify.com/v1/styles/osm-carto/style.json?apiKey=${KEY}`;
      map.setStyle(styleUrl);
      document.getElementById("toggle-theme").textContent = darkMode ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
    });

    const WMO = { 0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",45:"Fog",48:"Fog",51:"Drizzle",53:"Drizzle",55:"Drizzle",61:"Rain",63:"Rain",65:"Rain",71:"Snow",73:"Snow",75:"Snow",80:"Showers",81:"Showers",82:"Heavy showers",95:"Thunderstorm" };
    const WMO_EMOJI = { 0:"‚òÄÔ∏è",1:"üå§Ô∏è",2:"‚õÖ",3:"‚òÅÔ∏è",45:"üå´Ô∏è",48:"üå´Ô∏è",51:"üå¶Ô∏è",53:"üå¶Ô∏è",55:"üå¶Ô∏è",61:"üåßÔ∏è",63:"üåßÔ∏è",65:"üåßÔ∏è",71:"üå®Ô∏è",73:"üå®Ô∏è",75:"üå®Ô∏è",80:"üåßÔ∏è",81:"üåßÔ∏è",82:"‚õàÔ∏è",95:"‚õàÔ∏è" };

    async function showWeather(lat, lon){
      const el = document.getElementById("weather");
      try {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&temperature_unit=fahrenheit&timezone=auto`;
        const r = await fetch(url); const j = await r.json();
        const t = j.current?.temperature_2m; const code = j.current?.weather_code;
        const label = WMO[code] ?? "Weather"; const icon = WMO_EMOJI[code] ?? "üå°Ô∏è";
        if (typeof t === "number") el.innerHTML = `${icon} ${label} <span class="chip">${Math.round(t)}¬∞F</span>`; else el.textContent = "Weather unavailable";
      } catch(e) { console.warn("Weather fetch failed:", e); document.getElementById("weather").textContent = "Weather unavailable"; }
    }

    async function resolveCity(lat, lon){
      try {
        const url = `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lon}&type=city&apiKey=${KEY}`;
        const r = await fetch(url); const j = await r.json(); const p = j.features?.[0]?.properties || {};
        return p.city || p.town || p.village || p.suburb || p.county || p.state || "";
      } catch(e) { console.warn("reverse geocode failed", e); return ""; }
    }

    async function updateTitleWithCity(lat, lon, fallbackCity=""){
      const city = await resolveCity(lat, lon).then(c => c || fallbackCity);
      const el = document.getElementById("user-location"); if (el) el.textContent = city;
    }

    async function updateWeatherAndTitle(lat, lon, fallbackCity=""){
      showWeather(lat, lon); updateTitleWithCity(lat, lon, fallbackCity);
    }

    map.on("load", () => {
      const [lng, lat] = BIAS; updateWeatherAndTitle(lat, lng, "Minneapolis");
    });

    function setActiveModeButton(modeKey) {
      currentMode = modeKey;
      const mb = document.getElementById("mode-box");
      if (!mb) return;
      mb.querySelectorAll(".mode-btn").forEach(btn => {
        if (btn.dataset.mode === modeKey) btn.classList.add("active");
        else btn.classList.remove("active");
      });
      const goBtn = document.getElementById("mode-go");
      if (goBtn) goBtn.disabled = false;
    }

    function ensureModeBoxCreated() {
      if (modeBoxReady) return;
      const mb = document.getElementById("mode-box");

      // When you click Car / Walk / Bike / Transit
      mb.querySelectorAll(".mode-btn").forEach(btn => {
        btn.addEventListener("click", async () => {
          const mode = btn.dataset.mode;
          setActiveModeButton(mode); // highlight the selected button

          // If we already have valid From & To, preview the route
          if (state.from && state.to &&
              typeof state.from.lat === "number" && typeof state.from.lon === "number" &&
              typeof state.to.lat === "number" && typeof state.to.lon === "number") {
            await drawRoute(mode, false); // üëâ show distance box ONLY, no directions yet
          }
        });
      });

      const goBtn = document.getElementById("mode-go");
      if (goBtn) {
        goBtn.addEventListener("click", async () => {
          if (!currentMode) return;
          await drawRoute(currentMode, true); // üëâ now show directions box + list
        });
      }

      document.getElementById("mode-back").addEventListener("click", () => {
        const res = document.getElementById("mode-result");
        const resText = document.getElementById("mode-result-text");
        const dirBox = document.getElementById("directions");
        const dirWrapper = document.getElementById("directions-wrapper");

        if (res) res.style.display = "none";
        if (resText) resText.innerHTML = "";
        if (dirBox) dirBox.innerHTML = "";
        if (dirWrapper) dirWrapper.style.display = "none";

        document.getElementById("mode-summary-mini").textContent = "";
        document.getElementById("mode-box").classList.remove("show");
        document.getElementById("left-panel").classList.remove("hidden");
      });

      modeBoxReady = true;
    }

    function showModeChoice() {
      const fromLabel = document.getElementById("from")?.value.trim();
      const toLabel = document.getElementById("to")?.value.trim();

      (async () => {
        if ((!state.from || typeof state.from.lat !== "number") && fromLabel) {
          const g = await geocodeLabel(fromLabel);
          if (g) state.from = { lat: g.lat, lon: g.lon, label: g.label };
        }
        if ((!state.to || typeof state.to.lat !== "number") && toLabel) {
          const g2 = await geocodeLabel(toLabel);
          if (g2) state.to = { lat: g2.lat, lon: g2.lon, label: g2.label };
        }

        if (!state.from || !state.to ||
           typeof state.from.lat !== "number" || typeof state.from.lon !== "number" ||
           typeof state.to.lat !== "number" || typeof state.to.lon !== "number") {
          alert("Please ensure both From and To are selected or valid addresses.");
          return;
        }

        const fromL = fromLabel || state.from.label || "";
        const toL   = toLabel   || state.to.label   || "";
        if (fromL && toL) saveRecentSearch(fromL,toL);

        document.getElementById("left-panel").classList.add("hidden");
        ensureModeBoxCreated();
        const mb = document.getElementById("mode-box");
        mb.classList.add("show");

        const res = document.getElementById("mode-result");
        const resText = document.getElementById("mode-result-text");
        const dirBox = document.getElementById("directions");
        const dirWrapper = document.getElementById("directions-wrapper");

        if (res) res.style.display = "none";
        if (resText) resText.innerHTML = "";
        if (dirBox) dirBox.innerHTML = "";
        if (dirWrapper) dirWrapper.style.display = "none";

        document.getElementById("mode-summary-mini").textContent = "";

        setActiveModeButton("drive");

      })();
    }

    document.getElementById("go").addEventListener("click", async () => {
      const fromLabel = document.getElementById("from")?.value.trim();
      const toLabel = document.getElementById("to")?.value.trim();

      if ((!state.from || typeof state.from.lat !== "number") && fromLabel) {
        const g = await geocodeLabel(fromLabel); if (g) state.from = { lat: g.lat, lon: g.lon, label: g.label };
      }
      if ((!state.to || typeof state.to.lat !== "number") && toLabel) {
        const g2 = await geocodeLabel(toLabel); if (g2) state.to = { lat: g2.lat, lon: g2.lon, label: g2.label };
      }

      if (!fromLabel || !toLabel) { alert("Please enter both From and To."); return; }
      saveRecentSearch(fromLabel, toLabel);

      showModeChoice();
    });

    document.addEventListener("DOMContentLoaded", () => {
  renderRecents();
  renderFavMarkers();
  ensureModeBoxCreated();

  // üì± On phones: ask for location once
  if (window.innerWidth <= 600) {
    getMyLocation();   // browser will show the permission popup once
  }
});

  </script>
</body>
</html>
